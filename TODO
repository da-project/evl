Code
- Maven: fr.evl, plus tard avec fr.ill.code, evl
- Rename packages: fr.evl, plus tar fr.ill.code.evl
- Review interface
	Merge data : only a single interface : no data in generics interface
- Tutorials
	Merge Main.java and Foo.java into the same class.
	Find another name for process (mm? see the name given in reflection examples).
	Rename Process.method in tuto 4
- Remove Parameter.types
	Find a simpler syntax : 
	Method2<Void> copy1 = new Method2<Void>()
						.add(Copier.class, "copy", Parameter.types(A.class, K.class), copier)
	becomes ?
	Or in "builder" syntax:
				new Method2<Void>()
						.method(Copier.class, "copy", A.class, B.class).add(copier)
						.method(Copier.class, "copy", A.class, K.class).add(copier)
						
	With data:
				new Method2D<Void, Integer>()
						.method(Copier.class, "copy", A.class, B.class).add(copier, 11)
						.method(Copier.class, "copy", A.class, K.class).add(copier, 12)
	
	Check if copier is tested against Copier.class.

- MethodHandle to be considered: https://dzone.com/articles/setters-method-handles-and-java-11

- Test Caffeine Cache class.	
- Would it be possible to be less compile-time? To facilitate coding but with less control.
- See if lambdas can be used
- reimplement the comparators by a list of comparators
	possibility to add a comparator dynamically
- implement toString method of MultiMethodD
- check the classes to be ignored
	cleanup of the code: the methods to be not accessible to user
- javadoc (exclude some classes)
- put the tutorials on web site
- put javadoc on website
- test all errors : bad insertion, etc.
- refine perf tests to see if it would not be better to unfold invokeMethod call in invoke


- add the possibility to dynamically refine the FCOs
=> a list of FCOs, applied sequentially
=> provide refineComparator method that is called after comparator

Planning
- provide more precise plans
=> see if a technical article is ok
1. introduction
	provide some tutorials as examples
2. use cases

- study the C++ implementation with C++14
=> propose an architecture and main interfaces (e.g. need for string?)
=> multi_function to be compatible with std::function

Article
Explain not a new idea so we need to convince the user
When a real virtual method is defined, can we do it with a multi-method?
- Patterns GoF
	- Visitor
	- State (can be introduced anywhere)
	- ...
- Message queues
	- Take ConcurrentBlockingQueue
	=> say that it would be perfect in the actor model
	- Portable messages
	=> need for serializer/deserializer
	=> ex: zmq + protocol buffers + dispatcher (factory must be determined)
	=> best solution that separates different parts
	=> wait for C++ implementation

Tutorials
- Update web site
- Start examples (more concrete)
	Algorithms : calculate the descriptor of triangle, rectangle, hexagon
	- replace virtual inheritance by outside definitions
	- explain how visitor pattern would be used if not multi-method
	- replace in Method1
	- second Method1 for second algorithm
	- Method1 with simple argument enum to show the choice between algos
	- Method2 with additional value (completely dynamic)
	=> third party can add algo + type without code rewriting
	
	Dispatch
	- simple choice with instanceof
	=> replace any instanceof (with simplest code)
	=> explain reusability
	=> explain it is not type matching => BETTER more specialized !
	- simple message queue
	=> more complex
	=> explain reusability (key explanation)
	
- explain
	=> not a framework, can be used really often
	=> take the habit
	
- where to use
	=> avoid internal virtual methods
	=> code can be moved to the same class (it is better to move process functions in the same class)
	
remarks
- not implement resolve because potentially lots of classes
=> or imagine a base prototype
 
- Exception management
	- use runtime exceptions for insertion
	=> avoid too many compilation exceptions to treat that should be resolved once
	=> because we are using reflection layer
	
Web site:
Add index.html that let the choice between java and cpp implementations:

java:
Do like concurrentlinkedhashmap?
- provide link to bitbuckets web site (in Downloads & installation that will be renamed)
- remove Documentation
- javadoc

- recode Predicate without Method as DataType but the description of the method
=> break dependency to reflection?

Idea: Predicate inherited into Predicate0, Predicate1, ... Predicate7

We defined Multimethod m;
m.add(Foo.class, "foo", types(Predicate0), foo);

void foo(Predicate0 p, ...)

with Predicate.expression(EO e0, E1 e1, ...) : Predicate

we call m.invoke(Predicate.expression(x == 1, y != 3, ...))

Predicate.expression returns the first true predicate channel.
