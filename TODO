Code
- Maven: fr.evl, plus tard avec fr.ill.code, evl
- Rename packages: fr.evl, plus tar fr.ill.code.evl

- Add invoke arg1, arg2, ... in MultiMethodD

notes:
- MethodHandle.invoke is @PolymorphicSignature so that it is not possible to pass Object... args without args 0, args 1
	We define all the 8 methods.
- It is possible to generate code like templates: 
	https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html
	generate a virtual implementation that casts the arguments but that would not improve the perf because it is still needed to downcast.
	
	add(method)
		generate
		class "method.getName()+method.args" : public CacheItem
		invoke(Object objs...)
			return obj."method.getName"(objs 0, objs 1)
	
Java 11:
random access takes 9ms result 5244485
method in 14ms result 5244485
instanceof in 19ms result 5244485
map in 28ms result 5244485
method extern in 42ms result 5244485
method extern array in 24ms result 5244485
method reflect in 84ms result 5244485
method handle in 70ms result 5244485
method handle array in 42ms result 5244485
method 1 in 106ms result 5244485
method 2 in 158ms result 5244485
method 3 in 498ms result 5244485
method 1 in 98ms result 5244485
method 1 in 361ms result 5244485
method 1 in 202ms result 5244485
method 1 in 234ms result 5244485
method 1 in 540ms result 5244485
method 1 in 558ms result 5244485
method 1 in 718ms result 5244485


- Review interface
	Merge data : only a single interface : no data in generics interface
	Find a simpler syntax : 
	Method2<Void> copy1 = new Method2<Void>()
						.add(Copier.class, "copy", Parameter.types(A.class, K.class), copier)
	becomes ?
	Or in "builder" syntax:
				new Method2<Void>()
						.add(Copier.class, "copy", A.class, B.class).with(copier)
						.add(Copier.class, "copy", A.class, K.class).with(copier)
						
	With data:
				new Method2D<Void, Integer>()
						.add(Copier.class, "copy", A.class, B.class).with(copier, 11)
						.add(Copier.class, "copy", A.class, K.class).with(copier, 12)
	
	Static with data:
						.add(Copier.class, "copy", B.class, B.class).with(null, 13)
	
	Or:
						.add(copier, "copy", A.class, K.class).data(new Integer(12))
						.addAll(copier, "copy").data(new Integer(12)) // mark all the last added to set the data
						.add(Copier.class, "copy", B.class, B.class).data(new Integer(13)) // for static
	
	Checks at runtime:
	- return type? impose that the return type has a default constructor: so that it is possible to check OR provide an instance.
		classInstance.getConstructor().newInstance()
	- copier must be an instance of Copier.class.
	- data can be tested using the current comparator.
	- how to check if a method has no caller: exception at runtime if it is not static.
	=> unit tests for all possible errors.
	
	Ask Stu or ? to check the interface.

- Change default comparator: add priority to Asymmetric and Symmetric, remove Priority... 
	Default value is 0
	Change order: highest value provides more priority: so that it is always possible to force.

- Provide the request list of methods with associated objects.

- Tutorials
	Merge Main.java and Foo.java into the same class.
	Find another name for process (mm? see the name given in reflection examples).
	Rename Process.method in tuto 4


- Test Caffeine Cache class.	
- See if lambdas can be used
- reimplement the comparators by a list of comparators
	possibility to add a comparator dynamically
- implement toString method of MultiMethodD
- check the classes to be ignored
	cleanup of the code: the methods to be not accessible to user
- javadoc (exclude some classes)
- put the tutorials on web site
- put javadoc on website
- test all errors : bad insertion, etc.
- refine perf tests to see if it would not be better to unfold invokeMethod call in invoke

- add the possibility to dynamically refine the FCOs
=> a list of FCOs, applied sequentially?
=> provide refineComparator method that is called after comparator


Notes
- Too constraining to implement a cache based on array (define EvlObject class that registers a unique id by using a special factory)
	Future: mask map should be more suitable

Article
Explain not a new idea so we need to convince the user
When a real virtual method is defined, can we do it with a multi-method?
- Patterns GoF
	- Visitor
	- State (can be introduced anywhere)
	- ...
- Message queues
	- Take ConcurrentBlockingQueue
	=> say that it would be perfect in the actor model
	- Portable messages
	=> need for serializer/deserializer
	=> ex: zmq + protocol buffers + dispatcher (factory must be determined)
	=> best solution that separates different parts
	=> wait for C++ implementation

Tutorials
- Update web site
- Start examples (more concrete)
	Algorithms : calculate the descriptor of triangle, rectangle, hexagon
	- replace virtual inheritance by outside definitions
	- explain how visitor pattern would be used if not multi-method
	- replace in Method1
	- second Method1 for second algorithm
	- Method1 with simple argument enum to show the choice between algos
	- Method2 with additional value (completely dynamic)
	=> third party can add algo + type without code rewriting
	
	Dispatch
	- simple choice with instanceof
	=> replace any instanceof (with simplest code)
	=> explain reusability
	=> explain it is not type matching => BETTER more specialized !
	- simple message queue
	=> more complex
	=> explain reusability (key explanation)
	
- explain
	=> not a framework, can be used really often
	=> take the habit
	
- where to use
	=> avoid internal virtual methods
	=> code can be moved to the same class (it is better to move process functions in the same class)
	
remarks
- not implement resolve because potentially lots of classes
=> or imagine a base prototype
 
- Exception management
	- use runtime exceptions for insertion
	=> avoid too many compilation exceptions to treat that should be resolved once
	=> because we are using reflection layer
	
Web site:
Add index.html that let the choice between java and cpp implementations:

java:
Do like concurrentlinkedhashmap?
- provide link to bitbuckets web site (in Downloads & installation that will be renamed)
- remove Documentation
- javadoc

- recode Predicate without Method as DataType but the description of the method
=> break dependency to reflection?

Idea: Predicate inherited into Predicate0, Predicate1, ... Predicate7

We defined Multimethod m;
m.add(Foo.class, "foo", types(Predicate0), foo);

void foo(Predicate0 p, ...)

with Predicate.expression(EO e0, E1 e1, ...) : Predicate

we call m.invoke(Predicate.expression(x == 1, y != 3, ...))

Predicate.expression returns the first true predicate channel.
