Code
- Maven: fr.evl, later with fr.ill.code, evl
- Rename packages: fr.evl, plus tar fr.ill.code.evl

notes:
- Review interface
	Merge data : only a single interface : no data in generics interface
	Find a simpler syntax : 
	Method2<Void> copy1 = new Method2<Void>()
						.add(Copier.class, "copy", Parameter.types(A.class, K.class), copier, 12)
	becomes:
						.add(copier, "copy", A.class, K.class).data(new Integer(12))
						.addAll(copier, "copy").data(new Integer(12)) // mark all the last added to set the data
						.add(Copier.class, "copy", B.class, B.class).data(new Integer(13)) // for static
	
	Checks at runtime:
	- add static: check at it is static.
	- how to manage that method is static but added with object? Check it is static and do not bind if it is.
	- return type? impose that the return type has a default constructor: so that it is possible to check OR provide an instance.
		classInstance.getConstructor().newInstance()
	- copier must be an instance of Copier.class.
	- data can be tested using the current comparator.
	
	Change default comparator: add priority to Asymmetric and Symmetric, remove Priority... 
		Default value is 0
		Change order: highest value provides more priority: so that it is always possible to force.

	
Roadmap
1. Implement add and data in InvokableMethod1D, 2D, etc.
2. Remove all the methods from Method1, Method1D, Method2, etc.
3. Remove DataType from every ...D except comparators.
4. Remove ParameterTypes class.
5. Comparators include priority with default value : Object Comparator.getDefaultValue().
	
- unit tests for all possible errors.

- Provide the request list of methods with associated objects.

- Tutorials
	Merge Main.java and Foo.java into the same class.
	Find another name for process (mm? see the name given in reflection examples).
	Rename Process.method in tuto 4


- Test Caffeine Cache class.	
- See if lambdas can be used
- reimplement the comparators by a list of comparators
	possibility to add a comparator dynamically
- implement toString method of MultiMethodD
- Java 9 module?
- check the classes to be ignored
	cleanup of the code: the methods to be not accessible to user
- javadoc (exclude some classes)
- put the tutorials on web site
- put javadoc on website

- add the possibility to dynamically refine the comparators
	List of comparators, applied sequentially.


Notes
- Too constraining to implement a cache based on array (define EvlObject class that registers a unique id by using a special factory)
	Future: mask map should be more suitable
- MethodHandle.invoke is @PolymorphicSignature so that it is not possible to pass Object... args without args 0, args 1
	We define all the 7 methods.

Article
Explain not a new idea so we need to convince the user
When a real virtual method is defined, can we do it with a multi-method?
- Patterns GoF
	- Visitor
	- State (can be introduced anywhere)
	- ...
- Message queues
	- Take ConcurrentBlockingQueue
	=> say that it would be perfect in the actor model
	- Portable messages
	=> need for serializer/deserializer
	=> ex: zmq + protocol buffers + dispatcher (factory must be determined)
	=> best solution that separates different parts
	=> wait for C++ implementation

Tutorials
- Update web site
- Start examples (more concrete)
	Algorithms : calculate the descriptor of triangle, rectangle, hexagon
	- replace virtual inheritance by outside definitions
	- explain how visitor pattern would be used if not multi-method
	- replace in Method1
	- second Method1 for second algorithm
	- Method1 with simple argument enum to show the choice between algos
	- Method2 with additional value (completely dynamic)
	=> third party can add algo + type without code rewriting
	
	Dispatch
	- simple choice with instanceof
	=> replace any instanceof (with simplest code)
	=> explain reusability
	=> explain it is not type matching => BETTER more specialized !
	- simple message queue
	=> more complex
	=> explain reusability (key explanation)
	
- explain
	=> not a framework, can be used really often
	=> take the habit
	
- where to use
	=> avoid internal virtual methods
	=> code can be moved to the same class (it is better to move process functions in the same class)
	
remarks
- not implement resolve because potentially lots of classes
=> or imagine a base prototype
 
- Exception management
	- use runtime exceptions for insertion
	=> avoid too many compilation exceptions to treat that should be resolved once
	=> because we are using reflection layer
	
Web site:
Add index.html that let the choice between java and cpp implementations:

java:
Do like concurrentlinkedhashmap?
- provide link to bitbuckets web site (in Downloads & installation that will be renamed)
- remove Documentation
- javadoc

- recode Predicate without Method as DataType but the description of the method
=> break dependency to reflection?

Idea: Predicate inherited into Predicate0, Predicate1, ... Predicate7

We defined Multimethod m;
m.add(Foo.class, "foo", types(Predicate0), foo);

void foo(Predicate0 p, ...)

with Predicate.expression(EO e0, E1 e1, ...) : Predicate

we call m.invoke(Predicate.expression(x == 1, y != 3, ...))

Predicate.expression returns the first true predicate channel.
