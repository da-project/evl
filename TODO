Code
- reimplement the comparators by a list of comparators
	possibility to add a comparator dynamically
- implement toString method of MultiMethodD
- check the classes to be ignored, the methods to be not accessible to user
- javadoc (exclude some classes)
- put the tutorials on web site
- put javadoc on website
- test all errors : bad insertion, etc.
- refine perf tests to see if it would not be better to unfold invokeMethod call in invoke
- check the size of the application (with bounded cache)
- think about comparator copy by newInstance?



- add the possibility to dynamically refine the FCOs
=> a list of FCOs, applied sequentially
=> provide refineComparator method that is called after comparator

Planning
- provide more precise plans
=> see if a technical article is ok
1. introduction
	provide some tutorials as examples
2. use cases

- study the C++ implementation with C++14
=> propose an architecture and main interfaces (e.g. need for string?)
=> multi_function to be compatible with std::function

Article
Explain not a new idea so we need to convince the user
When a real virtual method is defined, can we do it with a multi-method?
- Patterns GoF
	- Visitor
	- State (can be introduced anywhere)
	- ...
- Message queues
	- Take ConcurrentBlockingQueue
	=> say that it would be perfect in the actor model
	- Portable messages
	=> need for serializer/deserializer
	=> ex: zmq + protocol buffers + dispatcher (factory must be determined)
	=> best solution that separates different parts
	=> wait for C++ implementation

Tutorials
- Update web site
- Start examples (more concrete)
	Algorithms : calculate the descriptor of triangle, rectangle, hexagon
	- replace virtual inheritance by outside definitions
	- explain how visitor pattern would be used if not multi-method
	- replace in Method1
	- second Method1 for second algorithm
	- Method1 with simple argument enum to show the choice between algos
	- Method2 with additional value (completely dynamic)
	=> third party can add algo + type without code rewriting
	
	Dispatch
	- simple choice with instanceof
	=> replace any instanceof (with simplest code)
	=> explain reusability
	=> explain it is not type matching => BETTER more specialized !
	- simple message queue
	=> more complex
	=> explain reusability (key explanation)
	
- explain
	=> not a framework, can be used really often
	=> take the habit
	
- where to use
	=> avoid internal virtual methods
	=> code can be moved to the same class (it is better to move process functions in the same class)
	
remarks
- not implement resolve because potentially lots of classes
=> or imagine a base prototype
 
- Exception management
	- use runtime exceptions for insertion
	=> avoid too many compilation exceptions to treat that should be resolved once
	=> because we are using reflection layer
	
Web site:
Add index.html that let the choice between java and cpp implementations:

java:
Do like concurrentlinkedhashmap?
- provide link to bitbuckets web site (in Downloads & installation that will be renamed)
- remove Documentation
- javadoc

- recode Predicate without Method as DataType but the description of the method
=> break dependency to reflection?

Idea: Predicate inherited into Predicate0, Predicate1, ... Predicate7

We defined Multimethod m;
m.add(Foo.class, "foo", types(Channel0), foo);

with Predicate.expression(EO e0, E1 e1, ...) : Predicate

we call m.invoke(Predicate.expression(x == 1, y != 3, ...))

Predicate.expression returns the first true predicate channel.
