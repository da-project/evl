- interface for creation of multimethods
	=> separate methods with Data and the other
- hide helper/implementation classes, some methods that must remain package protected 
- hide reflection method : propose interface with strings and .class?
- test all errors : bad insertion, etc.
- refine perf tests to see if it would not be better to unfold invokeMethod call in invoke
- not implement resolve because potentially lots of classes
=> or imagine a base prototype

- interface:

Method2<R>.from(obj, "name", Class<?>...)

Method2 m;
m.invoke(o1, o2, 3, true);

m.add(...)

possibilité de rajouter des familles de methodes

rajouter de façon optionnelle:
- Cache class
- FCO

rajouter de façon optionnelle

m.setData(d, T.class, "name", Class<?>...);

voir:
ConcurrentMap<K, V> cache = new ConcurrentLinkedHashMap.Builder<K, V>()
    .maximumWeightedCapacity(1000)
    .build();

=> Method2D.Builder<R, D>()
idem
Method2.Builder<R>()

ex: Method2D.Builder<R, D>().comparator(new MyComparator()).cache(new MyCache()).build();

Method2.Builder<R>().build();

rajouter les methodes à builder : methods(Method...) et data(DataType...) pour mettre des tableaux


reutiliser une method :
private Method1 m = Method1.Builder<Integer>().methods(...).build()


on peut faire la remarque qu'il pourrait etre plus general de garder obj pour invoke, oui mais les objets composites sont moins faisables.
=> ne permet que d'économiser de la mémoire en cache.
=> sauf si on mutualise les cache (faisable?)

