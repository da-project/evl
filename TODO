Todo
0. Maven central
1. Hugo website
2. Generate javadoc on website

Code
- Deployment
  maven central

- Doc
  website hugo
  website is more beautiful
- put the tutorials on website
- put javadoc on website

Notes
- How to convince: if it is simple to define a visitor or a state: we can do it anywhere.
- Too constraining to implement a cache based on array (define EvlObject class that registers a unique id by using a special factory)
	Future: mask map should be more suitable
- MethodHandle.invoke is @PolymorphicSignature so that it is not possible to pass Object... args without args 0, args 1
	We define all the 7 methods.
- Lambdas cannot be used because it is not possible to get abstract objects and runtime type information.
- The MethodHandle lookup is not easy to manage. If necessary, we can add an optional parameter lookup for all add methods.
	https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandles.Lookup.html

Later
- Unit tests for all possible errors
- Test Caffeine Cache class
- Java 9 modules
- Idea: reimplement the comparators by a list of comparators
	possibility to add a comparator dynamically

Article
Explain not a new idea so we need to convince the user
When a real virtual method is defined, can we do it with a multi-method?
- Patterns GoF
	- Visitor
	- State (can be introduced anywhere)
	- ...
- Message queues
	- Take ConcurrentBlockingQueue
	=> say that it would be perfect in the actor model
	- Portable messages
	=> need for serializer/deserializer
	=> ex: zmq + protocol buffers + dispatcher (factory must be determined)
	=> best solution that separates different parts
	=> wait for C++ implementation

Tutorials
- Update web site
- Start examples (more concrete)
	Algorithms : calculate the descriptor of triangle, rectangle, hexagon
	- replace virtual inheritance by outside definitions
	- explain how visitor pattern would be used if not multi-method
	- replace in Method1
	- second Method1 for second algorithm
	- Method1 with simple argument enum to show the choice between algos
	- Method2 with additional value (completely dynamic)
	=> third party can add algo + type without code rewriting
	
	Dispatch
	- simple choice with instanceof
	=> replace any instanceof (with simplest code)
	=> explain reusability
	=> explain it is not type matching => BETTER more specialized !
	- simple message queue
	=> more complex
	=> explain reusability (key explanation)
	
- explain
	=> not a framework, can be used really often
	=> take the habit
	
- where to use
	=> avoid internal virtual methods
	=> code can be moved to the same class (it is better to move process functions in the same class)
	
remarks
- not implement resolve because potentially lots of classes
=> or imagine a base prototype
 
- Exception management
	- use runtime exceptions for insertion
	=> avoid too many compilation exceptions to treat that should be resolved once
	=> because we are using reflection layer
	
Web site:
Add index.html that let the choice between java and cpp implementations:

java:
Do like concurrentlinkedhashmap?
- remove Documentation
- javadoc

- recode Predicate without Method as DataType but the description of the method
=> break dependency to reflection?

Idea: Predicate inherited into Predicate0, Predicate1, ... Predicate7

We defined Multimethod m;
m.add(Foo.class, "foo", types(Predicate0), foo);

void foo(Predicate0 p, ...)

with Predicate.expression(EO e0, E1 e1, ...) : Predicate

we call m.invoke(Predicate.expression(x == 1, y != 3, ...))

Predicate.expression returns the first true predicate channel.
